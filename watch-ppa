#!/usr/bin/python
# -*- coding: UTF8 -*-
# Copyright (C) 2012 Canonical
#
# Authors:
#  Didier Roche
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

import argparse
import logging
import os
import sys
import time

from cupstream2distro import launchpadmanager, packageinppamanager
from cupstream2distro.packageinppa import PackageInPPA
from cupstream2distro.packagemanager import list_packages_info_in_str
from cupstream2distro.settings import TIME_BETWEEN_PPA_CHECKS, TIME_BEFORE_STOP_LOOKING_FOR_SOURCE_PUBLISH


if __name__ == '__main__':

    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

    parser = argparse.ArgumentParser(description="Watch for published package in a ppa",
                                     epilog="series and ppa options can be set by the corresponding long option name env variables as well")

    parser.add_argument("-s", "--series", help="Serie used to build the package")
    parser.add_argument("-p", "--ppa", help="PPA to publish this package to (for instance: 'ubuntu-unity/daily-build')")
    parser.add_argument("-a", "--arch", action='store_true', help="Only consider the arch:all target")

    args = parser.parse_args()

    series = args.series
    ppa = args.ppa
    if not series:
        series = os.getenv("series")
    if not ppa:
        ppa = os.getenv("ppa")
    instance_info = "watching: {}, series: {}".format(ppa, series)

    if not series or not ppa:
        logging.error("Missing compulsory environment variables (ppa, series) {}".format(instance_info))
        sys.exit(1)

    # Prepare launchpad connection:
    lp_series = launchpadmanager.get_series(series)
    monitored_ppa = launchpadmanager.get_ppa(ppa)
    (available_archs, arch_all_arch) = launchpadmanager.get_all_available_archs_and_all_arch(lp_series, monitored_ppa)

    # Collecting all packages that have been uploaded to the ppa
    packages_not_in_ppa = set()
    packages_building = set()
    packages_failed = set()
    for (source, version) in packageinppamanager.get_all_packages_uploaded():
        # FIXME: is this a hack? yell yeah! We need to fix it once this part is under tests.
        # The idea will be to look at this source in the ppa, if there is one previous uploaded already,
        # look at the binary packages published/building and grab their arch (maybe a package is arch:all and don't build on powerpc for instance)
        # If they are not there, assume arch_all_arch, but don't block on arch that are on build-dep after a timeout of 1h for instance.
        # right now, autopilot-qt will build-dep forever on powerpc, hack that around
        available_archs_for_source = available_archs.copy()
        if source == "autopilot-qt":
            available_archs_for_source.remove("powerpc")
        packages_not_in_ppa.add(PackageInPPA(source, version, monitored_ppa, lp_series, available_archs_for_source, arch_all_arch))

    # Check the status regularly on all packages
    time_start_watching = time.time()
    while(packages_not_in_ppa or packages_building):
        logging.info("Checking the status for {}".format(list_packages_info_in_str(packages_not_in_ppa.union(packages_building))))
        packageinppamanager.update_all_packages_status(packages_not_in_ppa, packages_building, packages_failed, args.arch)

        # if we have some packages failing and no more build in progress, exit
        if packages_failed and not packages_building and not packages_not_in_ppa:
            logging.info("Some of the packages failed to build: {}".format(list_packages_info_in_str(packages_failed)))
            sys.exit(1)

        # if we have no package building or failing and have wait for long enough to have some package appearing in the ppa, exit
        if packages_not_in_ppa and not packages_building and ((time.time() - time_start_watching) > TIME_BEFORE_STOP_LOOKING_FOR_SOURCE_PUBLISH):
            logging.info("Some source packages were never published in the ppa: {}".format(list_packages_info_in_str(packages_not_in_ppa)))
            sys.exit(1)

        # exit if all is fine
        if not packages_not_in_ppa and not packages_building and not packages_failed:
            break

        time.sleep(TIME_BETWEEN_PPA_CHECKS)
