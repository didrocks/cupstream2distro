#!/usr/bin/python
# -*- coding: UTF8 -*-
# Copyright (C) 2012 Canonical
#
# Authors:
#  Didier Roche
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

import argparse
import os
import sys
import time

from ps2distro import launchpadmanager, packageinppamanager
from ps2distro.packageinppa import PackageInPPA
from ps2distro.packagemanager import list_packages_info_in_str
from ps2distro.settings import TIME_BETWEEN_PPA_CHECKS, TIME_BEFORE_STOP_LOOKING_FOR_SOURCE_PUBLISH


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description="Watch for published package in a ppa",
                                     epilog="serie and ppa options can be set by the corresponding long option name env variables as well")

    parser.add_argument("-s", "--serie", help="Serie used to build the package")
    parser.add_argument("-p", "--ppa", help="PPA to publish this package to (for instance: 'ubuntu-unity/daily-build')")
    parser.add_argument("-a", "--arch", action='store_true', help="Only consider the arch:all target")

    args = parser.parse_args()

    serie = args.serie
    ppa = args.ppa
    if not serie:
        serie = os.getenv("serie")
    if not ppa:
        ppa = os.getenv("ppa")
    instance_info = "watching: {}, serie: {}".format(ppa, serie)

    if not serie or not ppa:
        print("ERROR: missing compulsory environment variables (ppa, serie) {}".format(instance_info))
        sys.exit(1)

    # Prepare launchpad connection:
    lp_serie = launchpadmanager.get_serie(serie)
    monitored_ppa = launchpadmanager.get_ppa(ppa)
    (available_archs, arch_all_arch) = launchpadmanager.get_all_available_archs_and_all_arch(lp_serie, monitored_ppa)

    # Collecting all packages that have been uploaded to the ppa
    packages_not_in_ppa = set()
    packages_building = set()
    packages_failed = set()
    for (source, version) in packageinppamanager.get_all_packages_uploaded():
        packages_not_in_ppa.add(PackageInPPA(source, version, monitored_ppa, lp_serie, available_archs, arch_all_arch))

    # Check the status regularly on all packages
    time_start_watching = time.time()
    while(packages_not_in_ppa or packages_building):
        print("Checking the status for {}".format(list_packages_info_in_str(packages_not_in_ppa.union(packages_building))))
        packageinppamanager.update_all_packages_status(packages_not_in_ppa, packages_building, packages_failed, args.arch)

        # if we have some packages failing and no more build in progress, exit
        if packages_failed and not packages_building and not packages_not_in_ppa:
            print("Some of the packages failed to build: {}".format(list_packages_info_in_str(packages_failed)))
            sys.exit(1)

        # if we have no package building or failing and have wait for long enough to have some package appearing in the ppa, exit
        if packages_not_in_ppa and not packages_building and ((time.time() - time_start_watching) > TIME_BEFORE_STOP_LOOKING_FOR_SOURCE_PUBLISH):
            print("Some source packages were never published in the ppa: {}".format(list_packages_info_in_str(packages_not_in_ppa)))
            sys.exit(1)

        # exit if all is fine
        if not packages_not_in_ppa and not packages_building and not packages_failed:
            break

        time.sleep(TIME_BETWEEN_PPA_CHECKS)
