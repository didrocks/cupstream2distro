#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2012-2014 Canonical
#
# Authors:
#  Didier Roche
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

import argparse
import logging
import os
import sys


from cupstream2distro import launchpadmanager, packageinppamanager, silomanager
from cupstream2distro.stack import get_stack_packaging_change_status
from cupstream2distro.tools import generate_xml_artefacts, get_previous_distro_version_from_config
from cupstream2distro.settings import PUBLISHER_ARTEFACTS_FILENAME, PACKAGE_LIST_RSYNC_FILENAME_FORMAT, SRU_PPA, SILO_BUILTCHECKED, SILO_PUBLISHED


if __name__ == '__main__':

    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

    parser = argparse.ArgumentParser(description="Watch for published package in a ppa. Create a xml artefact if manual copy is needed.")

    parser.add_argument("--ignorestep", action='store_true', help="Ignore if previous step didn't successfully end.")
    parser.add_argument("-f", "--force", action='store_true', help="Publish even if there are packaging change. Only done after manual reviews of the diff.")

    args = parser.parse_args()

    silo_config = silomanager.load_config()

    series = launchpadmanager.get_resource_from_url(silo_config["global"]["series"]).name
    src_ppa = launchpadmanager.get_resource_from_url(silo_config["global"]["ppa"])
    src_pocket = 'Release'
    dest_link = silo_config["global"]["dest"]


    if silomanager.get_config_step(silo_config) != SILO_BUILTCHECKED:
        if args.ignorestep:
            logging.error("Last step didn't finish successfully, but the ignore flag is set.")
        else:
            logging.error("You need to either ignore that the previous step didn't finished successfully or ensuring that prepare, build and checked passed.")
            sys.exit(1)

    # getting the archives and series objects
    is_sru = not launchpadmanager.is_series_current(series.name)
    if not launchpadmanager.is_dest_ubuntu_archive(dest_link):
        dest_archive = launchpadmanager.get_resource_from_url(dest_link)
        dest_pocket = 'Release'
        logging.info("Direct copy from {src_archive} ({src_pocket}) to {dest_archive} ({dest_pocket}) for {series} series".format(
                      src_archive=src_ppa.name, src_pocket=src_pocket, dest_archive=dest_archive.name, dest_pocket=dest_pocket,
                      series=series))
    else:
        logging.info("Copy from {src_archive} ({src_pocket}) to {series} series in distro".format(
                      src_archive=src_ppa.name, src_pocket=src_pocket, series=series))
        distro = launchpadmanager.get_resource_from_url(dest_link)
        distro_pocket = 'Proposed'
        copy_from_ppa = src_ppa.name
        copy_from_ppa_pocket = src_pocket
        if is_sru:
            logging.info("This upload is part of a SRU. The {} ppa will be used as a staging archive".format(SRU_PPA))
            dest_archive = launchpadmanager.get_ppa(SRU_PPA)
            copy_from_ppa = SRU_PPA
            dest_pocket = 'Release'
            copy_from_ppa_pocket = dest_pocket

    manual_publish_cause_list = []

    all_packages_uploaded = packageinppamanager.get_all_packages_uploaded()

    # Generate global packaging change status
    manual_publish_cause_list.extend(get_stack_packaging_change_status(all_packages_uploaded))

    if stack.forced_manualpublish:
        message = "Manual publishing mode for this stack forced. Components ready for release are: {}".format(all_packages_uploaded)
        logging.info(message)
        manual_publish_cause_list.append(message)

    # we only go on manual publishing if we have something to publish
    if not args.force and all_packages_uploaded and (manual_publish_cause_list or stack.forced_manualpublish):
        logging.info("Don't upload the stack automatically.")
        generate_xml_artefacts("Publisher", manual_publish_cause_list, PUBLISHER_ARTEFACTS_FILENAME)
    else:
        package_to_copy = []
        for (source, version, tip_rev, branch) in all_packages_uploaded:
            logging.info("Copying {} ({})".format(source, version))
            # direct upload or SRU staging ppa copy
            if not launchpadmanager.is_dest_ubuntu_archive(dest_link) or is_sru:
                dest_archive.copyPackage(from_archive=src_ppa, from_pocket=src_pocket, from_series=series,
                                         include_binaries=True, to_pocket=dest_pocket, to_series=series,
                                         source_name=source, version=version)
            # generate a file for distro that will be rsynced from another place
            if launchpadmanager.is_dest_ubuntu_archive(dest_link):
                distro_version = get_previous_distro_version_from_config(source)
                package_to_copy.append("{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}".format(copy_from_ppa, copy_from_ppa_pocket, series, distro_pocket, series, source, version, distro_version))
        if package_to_copy:
            package_list_rsync_file = PACKAGE_LIST_RSYNC_FILENAME_FORMAT.format(os.path.abspath('').split(os.path.sep)[-1], series)
            logging.info("Writing {} for being able to rsync from main machine".format(package_list_rsync_file))
            with open(package_list_rsync_file, 'w') as f:
                f.write("\n".join(package_to_copy))
        silo_config['']
        generate_xml_artefacts("Publisher", [], PUBLISHER_ARTEFACTS_FILENAME)
        if not silomanager.set_config_step(silo_config, SILO_PUBLISHED):
            logging.error("Couldn't save the step in the configuration file.")
            sys.exit(1)
