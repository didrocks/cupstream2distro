#!/usr/bin/python -u
# -*- coding: utf-8 -*-
# Copyright (C) 2014 Canonical
#
# Authors:
#  Didier Roche
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

import argparse
import lazr
import logging
import os
import sys

from cupstream2distro import branchhandling, launchpadmanager, packageinppamanager, silomanager
from cupstream2distro.settings import SILO_BUILDPPA_SCHEME, SILOS_DIR, SILO_NAME_LIST, SILO_EMPTY
from cupstream2distro.tools import clean_source
from cupstream2distro.utils import ignored


def check_not_adding_new_components(project_name, allowed_components_from_previous_config, config_path):
    """Check that a self reconfigure doesn't add new components"""

    if project_name not in allowed_components_from_previous_config:
        message = "{} was not in the initial list of components for that silo. You can't reconfigure the silo yourself. Please ask the landing team to reconfigure it for you.".format(project_name)
        logging.error(message)
        silomanager.set_config_step(previous_config, -1, uri=config_path)
        silomanager.set_config_status(previous_config, "Reconfigure failed: " + message, uri=config_path)
        sys.exit(1)


if __name__ == '__main__':

    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser(description="Prepare and assign a free silo from a ppa",
                                     epilog="You need to either pass an addmps or addsources")

    parser.add_argument("series", help="Series used to build the package")

    parser.add_argument("--destppa", help="Consider this destppa instead of {series}-proposed")
    parser.add_argument("--addmps", nargs='*', default = [], help="Merge proposal urls")
    parser.add_argument("--addsources", nargs='*', default = [], help="Add sources packages that will be uploaded later manually to the ppa")
    parser.add_argument("--reconfiguresilo", help="Reconfigure an existing silo")
    parser.add_argument("--restricted", action='store_true', help="Restrict to only add MP for already locked components when reconfiguring an existing silo")
    parser.add_argument('-d', '--debug', action='store_true', default=False, help="Enable debug infos")


    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.debug else logging.INFO,
                        format="%(asctime)s %(levelname)s %(message)s")
    if args.debug:
        logging.debug("Debug mode enabled")

    series = launchpadmanager.get_series(args.series)
    if args.destppa:
        dest = launchpadmanager.get_ppa(args.destppa)
    else:
        dest = launchpadmanager.get_ubuntu_archive()

    if not args.addmps and not args.addsources:
        logging.error("You need at least specify a MP or a source")
        sys.exit(1)
    if args.restricted and not args.reconfiguresilo:
        logging.error("Restricted mode should only be used to reconfigure a silo")
        sys.exit(1)

    project_urls = args.addmps[:]
    project_urls.extend(args.addsources)
    logging.info("Configuring for {} ({}) in {}".format(", ".join(project_urls), series.name, dest.name))

    config = {"global": { "dest": dest.self_link,
                          "series": series.self_link,
                          "step": "",
                          "status": "" },
              "sources": [],
              "mps": {}
    }

    # create all silo names
    with ignored(OSError):
        os.mkdir(SILOS_DIR)
    for silo_name in SILO_NAME_LIST:
        with ignored(OSError):
            os.mkdir(os.path.join(SILOS_DIR, silo_name))

    # first, check that a silo is available
    if args.reconfiguresilo:
        silo_name = args.reconfiguresilo
        logging.info("Reconfiguring {} as an existing silo".format(silo_name))
        if silo_name not in SILO_NAME_LIST:
            logging.error("The silo name you provided {} isn't in the known silo name list".format(silo_name))
            sys.exit(1)
        previous_config = silomanager.load_config(os.path.join(SILOS_DIR, silo_name))
        if not previous_config:
            logging.error("silo {} isn't configured. You need the landing team to configure it and can't reconfigure a non attributed silo".format(silo_name))
            sys.exit(1)
        allowed_components_from_previous_config = previous_config['mps'].keys() + previous_config['sources']
        logging.debug("Components in previous configure: " + ", ".join(allowed_components_from_previous_config))
    else:
        logging.info("Checking that a silo is available")
        silo_name = silomanager.return_first_available_silo(SILOS_DIR)
        if not silo_name:
            logging.error("No silo is available")
            sys.exit(1)

    config_path = os.path.join(SILOS_DIR, silo_name)

    if args.addsources:
        logging.info("Additional packages will be directly uploaded to the ppa: {}".format(", ".join(args.addsources)))
        config["sources"] = args.addsources

    one_project_already_in_use = False
    # grab the project name of all MP
    for mp_url in args.addmps:
        mp = launchpadmanager.get_resource_from_url(mp_url)
        source_package_name = branchhandling.get_source_package_name_from_branch(mp.target_branch.web_link)
        project_name = mp.target_branch.project.name

        # ensure a self reconfiguring doesn't add new projects
        if args.reconfiguresilo and args.restricted:
            check_not_adding_new_components(project_name, allowed_components_from_previous_config, config_path)

        if (source_package_name != project_name):
            message = "Project name ({}) doesn't align with the source package name ({})".format(project_name, source_package_name)
            logging.warning(message)

        config["mps"].setdefault(source_package_name, []).append(mp.self_link)

        # check that any of those components are part of any current transaction
        if not silomanager.is_project_not_in_any_configs(mp.target_branch.project.name, series, dest, SILOS_DIR, args.reconfiguresilo):
            one_project_already_in_use = True

    # check that additional sources are not as well already in use
    for source in config["sources"]:

        # ensure a self reconfiguring doesn't add new projects
        if args.reconfiguresilo and args.restricted:
            check_not_adding_new_components(project_name, allowed_components_from_previous_config, config_path)

        if not silomanager.is_project_not_in_any_configs(source, series, dest, SILOS_DIR, args.reconfiguresilo):
            one_project_already_in_use = True

    if one_project_already_in_use:
        logging.error("One or more projects are already in use for the same destination and series in another silo (see above)")
        sys.exit(1)

    # check that all MPs for a source are targetting the same branch
    logging.info("Checking that all target branch for the same source in mps are targetting the same branches")
    all_same_dest = True
    for source in config["mps"]:
        first_mp = None
        for mp_link in config['mps'][source]:
            mp = launchpadmanager.get_resource_from_token(mp_link)
            if not first_mp:
                first_mp = mp
            else:
                current_branch_link = mp.target_branch.web_link
                if current_branch_link != first_mp.target_branch.web_link:
                    logging.error("{} is targetting {} while {} is targetting {}".format(mp.web_link, current_branch_link, first_mp.web_link, first_mp.target_branch.web_link))
                    all_same_dest = False

    if not all_same_dest:
        logging.error("Not all MP targetting the same source package are targetting the same branch. Please recheck your configuration.")
        sys.exit(1)

    ppa_uri = SILO_BUILDPPA_SCHEME.format(silo_name)
    try:
        ppa = launchpadmanager.get_ppa(ppa_uri)
    except lazr.restfulclient.errors.NotFound:
        logging.error("PPA {} not found".format(ppa_uri))
        sys.exit(1)
    config["global"]["ppa"] = ppa.self_link
    if not silomanager.save_config(config, config_path):
        sys.exit(1)
    logging.info("Assigning \"{}\" as silo. Build PPA is available at {}".format(silo_name, ppa.web_link))

    # if reconfigure, ensure we remove all projects file and packages from the ppa that are not to take into account anymore
    if args.reconfiguresilo:
        logging.info("Check and clean all removed sources")
        silo_name = args.reconfiguresilo
        all_silo_projects = silomanager.get_all_projects(config)
        # remove all files related to sources that are not in the configuration anymore
        for (source, version, rev, branch) in packageinppamanager.get_all_packages_uploaded():
            if source not in all_silo_projects:
                logging.info("Removing {} from ppa and configuration".format(source))
                clean_source(source)
                for pkg in ppa.getPublishedSources(exact_match=True, distro_series=series, source_name=source):
                    pkg.requestDeletion()
        # NOTE: we don't wait for the removal to be published. Shouldn't be an issue

    silomanager.set_config_step(config, SILO_EMPTY, uri=config_path)
    silomanager.set_config_status(config, "Silo ready", uri=config_path, add_url=False)
