#!/usr/bin/python
# -*- coding: UTF8 -*-
# Copyright (C) 2012 Canonical
#
# Authors:
#  Didier Roche
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

import argparse
import logging
import os
import sys

from cupstream2distro import launchpadmanager, packageinppamanager
from cupstream2distro.branchhandling import get_packaging_diff_filename, propose_branch_for_merging
from cupstream2distro.packageinppa import get_previous_packaging_version_from_config
from cupstream2distro.stacks import generate_dep_status_message
from cupstream2distro.tools import generate_xml_artefacts
from cupstream2distro.settings import PUBLISHER_ARTEFACTS_FILENAME, PACKAGE_LIST_RSYNC_FILENAME_FORMAT


if __name__ == '__main__':

    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

    parser = argparse.ArgumentParser(description="Watch for published package in a ppa. Create a xml artefact if manual copy is needed.",
                                     epilog="series, ppa and JOB_NAME options can be set by the corresponding long option name env variables as well")

    parser.add_argument("-f", "--force", action='store_true', help="Publish even if there are packaging change. Only done after manual reviews of the diff.")
    parser.add_argument("-s", "--series", help="Serie used to build the package")
    parser.add_argument("-p", "--ppa", help="PPA to publish this package to (for instance: 'ubuntu-unity/daily-build')")
    parser.add_argument("-d", "--destppa", help="Consider this destppa instead of {series}-proposed")
    parser.add_argument("-j", "--JOB_NAME", help="Set this JOB_NAME for generating an unique id for the file to rsync")

    args = parser.parse_args()

    series = args.series
    ppa = args.ppa
    jobname = args.JOB_NAME
    if not series:
        series = os.getenv("series")
    if not ppa:
        ppa = os.getenv("ppa")
    if not jobname:
        jobname = os.getenv("JOB_NAME")

    if not ppa or not series:
        logging.info("ppa and series parameters are mandatory.")
        sys.exit(1)

    # getting the archives and series objects
    if args.destppa:
        dest_archive = launchpadmanager.get_ppa(args.destppa)
        dest_pocket = 'Release'
    else:
        dest_archive = launchpadmanager.get_ubuntu_archive()
        dest_pocket = 'Proposed'
        if not jobname:
            logging.info("JOB_NAME is mandatory if you want to release to the main ubuntu archive")
            sys.exit(1)
    src_ppa = launchpadmanager.get_ppa(ppa)
    src_pocket = 'Release'

    logging.info("Copying from {src_archive} ({src_pocket}) to {dest_archive} ({dest_pocket}) for {series} series".format(
          src_archive=src_ppa, src_pocket=src_pocket, dest_archive=dest_archive, dest_pocket=dest_pocket,
          series=series))
    manual_publish_cause_list = []

    # Generate global packaging change status
    packaging_change_status = []
    for (source, version) in packageinppamanager.get_all_packages_uploaded():
        if os.path.exists(get_packaging_diff_filename(source, version)):
            message = "Packaging change for {} ({}).".format(source, version)
            logging.warning(message)
            packaging_change_status.append(message)
    manual_publish_cause_list.extend(packaging_change_status)

    # Generate global stack status based on rdepends
    stackname = os.getcwd().split(os.path.sep)[-1]
    manual_publish_cause_list.extend(generate_dep_status_message(stackname))

    if manual_publish_cause_list and not args.force:
        logging.info("Don't upload the stack automatically.")
        generate_xml_artefacts("Publisher", manual_publish_cause_list, PUBLISHER_ARTEFACTS_FILENAME)
    else:
        package_to_copy = []
        for (source, version) in packageinppamanager.get_all_packages_uploaded():
            logging.info("Copying {} ({})".format(source, version))
            propose_branch_for_merging(source, version)
            if args.destppa:  # direct upload
                dest_archive.copyPackage(from_archive=src_ppa, from_pocket=src_pocket, from_series=series,
                                         include_binaries=True, to_pocket=dest_pocket, to_series=series,
                                         source_name=source, version=version)
            else:  # generate a file that will be rsynced from another place
                previous_packaging_version = get_previous_packaging_version_from_config(source)
                package_to_copy.append("{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}".format(ppa, src_pocket, series, dest_pocket, series, source, version, previous_packaging_version))
        if package_to_copy:
            logging.info("Writing {} for being able to rsync from main machine".format(PACKAGE_LIST_RSYNC_FILENAME_FORMAT.format(jobname)))
            with open(PACKAGE_LIST_RSYNC_FILENAME_FORMAT.format(jobname), 'w') as f:
                f.write("\n".join(package_to_copy))
        generate_xml_artefacts("Publisher", [], PUBLISHER_ARTEFACTS_FILENAME)
