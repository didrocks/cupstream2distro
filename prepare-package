#!/usr/bin/python
# -*- coding: UTF8 -*-
# Copyright (C) 2012 Canonical
#
# Authors:
#  Didier Roche
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

import os
import sys

from ps2distro import branchhandling, packagemanager, launchpadmanager


if __name__ == '__main__':

    project_branch = os.getenv("projectbranch")
    serie = os.getenv("serie")
    ppa = os.getenv("ppa")
    instance_info = "for project_branch: {}, serie: {}".format(project_branch, serie)

    if not project_branch or not serie or not ppa:
        print("ERROR: missing compulsory environment variables (projectbranch, serie, ppa) {}".format(instance_info))
        sys.exit(1)
    if not " " in project_branch:
        print("ERROR: projectbranch should be in the form: 'source_package lp:branch_path' {}".format(instance_info))
        sys.exit(1)
    (source_package, branch_path) = project_branch.split(" ")

    # Grab project branch
    print("Branching {} to {}".format(branch_path, source_package))
    branchhandling.get_branch(branch_path, source_package)
    os.chdir(source_package)

    # Get changelog informations
    print("Get changelog info")
    with open("debian/changelog") as changelog:
        last_upstream_rev = packagemanager.get_latest_upstream_bzr_rev(changelog)
    previous_packaging_version = packagemanager.get_packaging_version()

    if (source_package != packagemanager.get_packaging_sourcename()):
        print("ERROR: projectbranch doesn't specify the same source name than the packaging itself {}".format(instance_info))
        sys.exit(1)

    # Check version in distro
    print("Get version available in distro")
    distro_version = packagemanager.get_current_version_for_serie(source_package, serie)
    # FIXME: if previous_packaging_version is UNRELEASED and the released version is in distro?
    if packagemanager.is_version1_higher_than_version2(distro_version, previous_packaging_version):
        print("A manual upload to distro ({}) has been done for that component, compare to latest version in trunk ({}). "
              "Ignoring that component for {}.".format(distro_version, previous_packaging_version, instance_info))
        # TODO: open a merge proposal with the diff from distro and approve.
        sys.exit(3)

    # Check if new revision to publish
    print("Check if new revision were published")
    tip_bzr_rev = branchhandling.get_tip_bzr_revision()
    # +1 as there is at least an additional automatic commit for latest changelog content of last release.
    if tip_bzr_rev <= last_upstream_rev + 1:
        print("No new revision published since last daily push, no need to upload this component")
        sys.exit(0)

    # Prepare changelog
    print("Prepare changelog content")
    packaging_version = packagemanager.create_new_packaging_version(previous_packaging_version)
    authors_bugs = branchhandling.collect_author_bugs(last_upstream_rev + 1, source_package)
    authors_bugs_with_title = launchpadmanager.get_bugs_titles(authors_bugs)
    packagemanager.update_changelog(packaging_version, serie, tip_bzr_rev, authors_bugs_with_title)

    # opens bugs
    print("Sync launchpad with current proposed work")
    branchhandling.commit_release(packaging_version, tip_bzr_rev)
    bugs_set = set()
    for author in authors_bugs:
        bugs_set = bugs_set.union(authors_bugs[author])
    launchpadmanager.open_bugs_for_source(bugs_set, source_package, serie)

    print("Build source package and upload to the ppa")
    packagemanager.build_package()
    os.chdir('..')
    packagemanager.upload_package(source_package, packaging_version, ppa)


# 1. stop if an intermediate upload has been done to ubuntu but not backported in the packaging branch
# 2. collect all bugs that have been fixed in upstream trunk, and sort them by name in the changelog. The matching is really permissive: wide variety of format either --fixes lp: or in the commit message
# 3. Filters them with the eventual manual cherry-pick upload done in between (don't repeat if already fixed in distro)
# 4. Opens the downstream task automatically, nominate for a serie SRU if not the current one.
# 5. Compute the version with <upstream_version>daily<version>
#    Version would be <upstream_version>daily<yy.mm.dd(.minor)>-0ubuntu1
#    if we already have something delivered today, it will be .minor, then, .minor+1…'
#    this enables 7.0daily12.11.09-0ubuntu2, then the day after 7.0daily12.11.10-0ubuntu1
#    multiple uploads the same day will then be 7.0daily12.11.10.1-0ubuntu1, 7.0daily12.11.10.2-0ubuntu1…
#    if upstream go with 7.0.1, it's still handled thanks to 7.0daily and not 7.0.daily ;) (and so, will give 7.0.1daily12.11.11-0ubuntu1 for instance)
#    Also, boostrapping or directly upload is handled, like 7.2-0ubuntu3, next daily upload will be 7.2daily12.11.15-0ubuntu1
# 8. propose for merging and accept automatically the changelog changes for the day.
# 
# The bug collect doesn't depend on when the changelog commit is merged



# Metrics: number of bugs fixed per stack, per component, which ones…
# TODO: clean the ppa (remove all old unpublished packages)
