#!/usr/bin/python
# -*- coding: UTF8 -*-
# Copyright (C) 2012 Canonical
#
# Authors:
#  Didier Roche
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

import argparse
import logging
import os
import sys

from cupstream2distro import branchhandling, packagemanager, launchpadmanager
from cupstream2distro.tools import generate_xml_artefacts, save_project_config
from cupstream2distro.settings import PREPARE_ARTEFACTS_FILENAME_FORMAT


if __name__ == '__main__':

    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

    parser = argparse.ArgumentParser(description="Prepare package for a specific component to push to a ppa",
                                     epilog="All options can be set by the corresponding long option name env variables as well")

    parser.add_argument("-n", "--sourcename", help="Source package name")
    parser.add_argument("-b", "--branch", help="Branch to use as the upstream source")
    parser.add_argument("-s", "--series", help="Serie used to build the package")
    parser.add_argument("-p", "--ppa", help="PPA to publish this package to (for instance: 'ubuntu-unity/daily-build')")
    args = parser.parse_args()

    source_package_name = args.sourcename
    branch = args.branch
    series = args.series
    ppa = args.ppa
    if not source_package_name:
        source_package_name = os.getenv("sourcename")
    if not branch:
        branch = os.getenv("branch")
    if not series:
        series = os.getenv("series")
    if not ppa:
        ppa = os.getenv("ppa")
    instance_info = "for source: {}, branch: {}, series: {}".format(source_package_name, branch, series)

    if not source_package_name or not branch or not series or not ppa:
        logging.error("Missing compulsory environment variables (sourcename, branch, series, ppa) {}".format(instance_info))
        sys.exit(1)

    # Grab project branch
    logging.info("Branching {} to {}".format(branch, source_package_name))
    branchhandling.get_branch(branch, source_package_name)
    os.chdir(source_package_name)

    # Get changelog informations
    logging.info("Get changelog info")
    with open("debian/changelog") as changelog:
        last_upstream_rev = packagemanager.get_latest_upstream_bzr_rev(changelog)
    previous_packaging_version = packagemanager.get_packaging_version()

    if (source_package_name != packagemanager.get_packaging_sourcename()):
        logging.error("Projectbranch doesn't specify the same source name than the packaging itself {}".format(instance_info))
        sys.exit(1)

    # Check version in ppa
    logging.info("Get previous version in ppa")
    version_in_ppa = packagemanager.get_current_version_for_series(source_package_name, series, ppa)
    if packagemanager.is_version1_higher_than_version2(version_in_ppa, previous_packaging_version):
        logging.info("A version in the ppa ({}) is higher than the previous automated upload ({}) (tests/builds failing?). Basing on that one.".format(version_in_ppa, previous_packaging_version))
        previous_packaging_version = version_in_ppa

    # Check version in distro
    logging.info("Get version available in distro")
    distro_version = packagemanager.get_current_version_for_series(source_package_name, series)
    artefacts_file = os.path.abspath(os.path.join(
                        '..', PREPARE_ARTEFACTS_FILENAME_FORMAT.format(
                            source_package_name, distro_version)))

    # FIXME: if previous_packaging_version is UNRELEASED and the released version is in distro?
    if packagemanager.is_version1_higher_than_version2(distro_version, previous_packaging_version):
        message = ("A manual upload to distro ({}) has been done for that component but is not in trunk which is still at {}. "
                   "Ignoring that component {}.".format(distro_version, previous_packaging_version, instance_info))
        logging.info(message)
        generate_xml_artefacts("Prepare",  [message], artefacts_file)
        # TODO: open a merge proposal with the diff from distro and approve.
        sys.exit(0)

    # Check if new revision to publish
    logging.info("Check if new revision were published")
    tip_bzr_rev = branchhandling.get_tip_bzr_revision()
    if not packagemanager.is_new_release_needed(tip_bzr_rev, last_upstream_rev, source_package_name):
        logging.info("No new useful revision published since last daily push, no need to upload this component")
        sys.exit(0)

    packaging_version = packagemanager.create_new_packaging_version(previous_packaging_version)

    # Refresh symbol files
    logging.info("Update symbol files version if needed")
    packagemanager.refresh_symbol_files(packaging_version)

    # Prepare changelog
    logging.info("Prepare changelog content")
    authors_bugs = branchhandling.collect_author_bugs(last_upstream_rev + 1, source_package_name)
    authors_bugs_with_title = launchpadmanager.get_bugs_titles(authors_bugs)
    packagemanager.update_changelog(packaging_version, series, tip_bzr_rev, authors_bugs_with_title)

    # Prepare if a packaging change is part of the diff
    logging.info("Generate a diff if meaningfull packaging changes")
    branchhandling.generate_diff_in_branch(last_upstream_rev, source_package_name, packaging_version)

    # opens bugs
    logging.info("Sync launchpad with current proposed work")
    branchhandling.commit_release(packaging_version, tip_bzr_rev)
    bugs_set = set()
    for author in authors_bugs:
        bugs_set = bugs_set.union(authors_bugs[author])
    launchpadmanager.open_bugs_for_source(bugs_set, source_package_name, series)

    logging.info("Build source package and upload to the ppa")
    packagemanager.build_package(series)
    os.chdir('..')
    packagemanager.upload_package(source_package_name, packaging_version, ppa)

    # Save infos for other jobs
    save_project_config(source_package_name, branch, previous_packaging_version, packaging_version)

    # generate artefacts
    os.chdir(source_package_name)
    generate_xml_artefacts("Prepare",  [], artefacts_file)

# 1. stop if an intermediate upload has been done to ubuntu but not backported in the packaging branch
# 1.1 Only consider the upload if there has been some new commits in the branch (not counting the previous changelog committed or any upload done directly to distro which have been backported to trunk)
# 2. collect all bugs that have been fixed in upstream trunk, and sort them by name in the changelog. The matching is really permissive: wide variety of format either --fixes lp: or in the commit message
# 3. Filters them with the eventual manual cherry-pick upload done in between (don't repeat if already fixed in distro)
# 4. Refresh the debian/symbols automatically (with "replaceme" magic tag) to refresh on the real day the component is released
# 5. Opens the downstream task automatically, nominate for a series SRU if not the current one.
# 6. Compute the version with <upstream_version>daily<version>
#    Version would be <upstream_version>daily<yy.mm.dd(.minor)>-0ubuntu1
#    if we already have something delivered today, it will be .minor, then, .minor+1…'
#    this enables 7.0daily12.11.09-0ubuntu2, then the day after 7.0daily12.11.10-0ubuntu1
#    multiple uploads the same day will then be 7.0daily12.11.10.1-0ubuntu1, 7.0daily12.11.10.2-0ubuntu1…
#    if upstream go with 7.0.1, it's still handled thanks to 7.0daily and not 7.0.daily ;) (and so, will give 7.0.1daily12.11.11-0ubuntu1 for instance)
#    Also, boostrapping or directly upload is handled, like 7.2-0ubuntu3, next daily upload will be 7.2daily12.11.15-0ubuntu1
# 7. Prepare a relevant diff if there are some packaging changes, containing packaging changes itselfs as well as
#    autotools and cmake files.
# 8. propose for merging and accept automatically the changelog changes for the day.
# 9. Create the source package inside a cowbuilder chroot corresponding to the current series, after installing all the needed build-deps to avoid having
#    the master machine crafted with build-deps across different series.
# 10. Finally push that to a ppa.
# 11. If a version in the ppa fail (build failure, tests not passing), then another try the same day will bump the version from the last upload in the ppa
# 
# The bug collect doesn't depend on when the changelog commit is merged



# Metrics: number of bugs fixed per stack, per component, which ones…
# TODO: clean the ppa (remove all old unpublished packages)
